{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_FAST_REFRESH = 'fast-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  previousTree,\n  serverResponse,\n}: {\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport type RouterNavigate = (\n  href: string,\n  navigateType: 'push' | 'replace',\n  shouldScroll: boolean\n) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface FastRefreshAction {\n  type: typeof ACTION_FAST_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The buildId is used to do a mpaNavigation when the server returns a different buildId.\n   * It is used to avoid issues where an older version of the app is loaded in the browser while the server has a new version.\n   */\n  buildId: string\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | FastRefreshAction\n  | ServerActionAction\n>\n\nexport function isThenable(value: any): value is Promise<AppRouterState> {\n  // TODO: We don't gain anything from this abstraction. It's unsound, and only\n  // makes sense in the specific places where we use it. So it's better to keep\n  // the type coercion inline, instead of leaking this to other places in\n  // the codebase.\n  return (\n    value &&\n    (typeof value === 'object' || typeof value === 'function') &&\n    typeof value.then === 'function'\n  )\n}\n"],"names":["ACTION_REFRESH","ACTION_NAVIGATE","ACTION_RESTORE","ACTION_SERVER_PATCH","ACTION_PREFETCH","ACTION_FAST_REFRESH","ACTION_SERVER_ACTION","PrefetchKind","PrefetchCacheEntryStatus","isThenable","value","then"],"mappings":";;;;;;;;;;;;AAOO,MAAMA,iBAAiB;AACvB,MAAMC,kBAAkB;AACxB,MAAMC,iBAAiB;AACvB,MAAMC,sBAAsB;AAC5B,MAAMC,kBAAkB;AACxB,MAAMC,sBAAsB;AAC5B,MAAMC,uBAAuB;;UAuIxBC,YAAAA;;;;GAAAA,gBAAAA,CAAAA,eAAAA,CAAAA,CAAAA;;UA8DAC,wBAAAA;;;;;GAAAA,4BAAAA,CAAAA,2BAAAA,CAAAA,CAAAA;AA+DL,SAASC,WAAWC,KAAU;IACnC,6EAA6E;IAC7E,6EAA6E;IAC7E,uEAAuE;IACvE,gBAAgB;IAChB,OACEA,SACC,CAAA,OAAOA,UAAU,YAAY,OAAOA,UAAU,UAAS,KACxD,OAAOA,MAAMC,IAAI,KAAK;AAE1B"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["createHrefFromUrl","url","includeHash","pathname","search","hash"],"mappings":";;;AAAO,SAASA,kBACdC,GAA8C,EAC9CC,WAA2B;IAA3BA,IAAAA,gBAAAA,KAAAA,GAAAA,cAAuB;IAEvB,OAAOD,IAAIE,QAAQ,GAAGF,IAAIG,MAAM,GAAIF,CAAAA,cAAcD,IAAII,IAAI,GAAG,EAAC;AAChE"}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/fetch-server-response.ts"],"sourcesContent":["'use client'\n\n// @ts-ignore\n// eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\nconst { createFromFetch } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport type {\n  FlightRouterState,\n  FlightData,\n  NextFlightResponse,\n} from '../../../server/app-render/types'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n} from '../app-router-headers'\nimport { urlToUrlWithoutFlightMarker } from '../app-router'\nimport { callServer } from '../../app-call-server'\nimport { PrefetchKind } from './router-reducer-types'\nimport { hexHash } from '../../../shared/lib/hash'\n\nexport type FetchServerResponseResult = [\n  flightData: FlightData,\n  canonicalUrlOverride: URL | undefined,\n  postponed?: boolean,\n  intercepted?: boolean,\n]\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return [urlToUrlWithoutFlightMarker(url).toString(), undefined, false, false]\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  flightRouterState: FlightRouterState,\n  nextUrl: string | null,\n  currentBuildId: string,\n  prefetchKind?: PrefetchKind\n): Promise<FetchServerResponseResult> {\n  const headers: {\n    [RSC_HEADER]: '1'\n    [NEXT_ROUTER_STATE_TREE]: string\n    [NEXT_URL]?: string\n    [NEXT_ROUTER_PREFETCH_HEADER]?: '1'\n  } = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(\n      JSON.stringify(flightRouterState)\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  const uniqueCacheQuery = hexHash(\n    [\n      headers[NEXT_ROUTER_PREFETCH_HEADER] || '0',\n      headers[NEXT_ROUTER_STATE_TREE],\n      headers[NEXT_URL],\n    ].join(',')\n  )\n\n  try {\n    let fetchUrl = new URL(url)\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (fetchUrl.pathname.endsWith('/')) {\n          fetchUrl.pathname += 'index.txt'\n        } else {\n          fetchUrl.pathname += '.txt'\n        }\n      }\n    }\n\n    // Add unique cache query to avoid caching conflicts on CDN which don't respect to Vary header\n    fetchUrl.searchParams.set(NEXT_RSC_UNION_QUERY, uniqueCacheQuery)\n\n    const res = await fetch(fetchUrl, {\n      // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n      credentials: 'same-origin',\n      headers,\n    })\n\n    const responseUrl = urlToUrlWithoutFlightMarker(res.url)\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    let isFlightResponse = contentType === RSC_CONTENT_TYPE_HEADER\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const [buildId, flightData]: NextFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n      }\n    )\n\n    if (currentBuildId !== buildId) {\n      return doMpaNavigation(res.url)\n    }\n\n    return [flightData, canonicalUrl, postponed, interception]\n  } catch (err) {\n    console.error(\n      `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n      err\n    )\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return [url.toString(), undefined, false, false]\n  }\n}\n"],"names":["NEXT_ROUTER_PREFETCH_HEADER","urlToUrlWithoutFlightMarker","undefined","headers","encodeURIComponent","NEXT_URL","NEXT_ROUTER_STATE_TREE","join","fetchUrl","process","NODE_ENV","uniqueCacheQuery","res","fetch","credentials","canonicalUrl","responseUrl","contentType","postponed","get","NEXT_DID_POSTPONE_HEADER","interception","isFlightResponse","RSC_CONTENT_TYPE_HEADER","callServer","doMpaNavigation","url","flightData","console","error"],"mappings":";;;;;;;;;AAAA;AAGA,aAAA;AACA,6DAAA;AACA,oEAGc;AAUd,MAAA,EAAA,eACEA,EAAAA,GAAAA;;;;;;SAqBA,gBAAO,GAAA;WAACC;QAA6CC,CAAAA,GAAAA,qYAAAA,CAAAA,8BAAAA,EAAAA,KAAAA,QAAAA;QAAW;QAAO;QAAM;KAC/E;AAEA;AAUQC,eAKF,oBAAA,GAAA,EAAA,iBAAA,EAAA,OAAA,EAAA,cAAA,EAAA,YAAA;UACF,UAAA;QACA,yBAAc;QACd,CAAA,gZAAA,CAAA,aAAA,CAAA,EAAA;QACA,mCAA0BC;QAG5B,CAAA,gZAAA,CAAA,yBAAA,CAAA,EAAA,mBAAA,KAAA,SAAA,CAAA;IAEA;;;;;;UAOED,iBAAQH,uaAAAA,CAAAA,eAAAA,CAAAA,IAA4B,EAAA;QACtC,OAAA,CAAA,gZAAA,CAAA,8BAAA,CAAA,GAAA;IAEA;QACEG,SAAQE;QACV,OAAA,CAAA,gZAAA,CAAA,WAAA,CAAA,GAAA;IAEA;UAEIF,mBAAQH,CAAAA,GAAAA,qXAAAA,CAAAA,UAAAA,EAAAA;QACRG,OAAO,CAACG,gZAAAA,CAAAA,8BAAuB,CAAA,IAAA;QAC/BH,OAAO,CAACE,gZAAAA,CAAAA,yBAAS,CAAA;QACjBE,OAAK,CAAA,gZAAA,CAAA,WAAA,CAAA;KAGT,CAAA,IAAI,CAAA;;QACF,IAAIC;QACJ,IAAIC,WAAW,IAACC,IAAAA;;;;QAWhBF,8FAAgDG;QAEhD,SAAMC,YAAYC,CAAAA,GAAML,CAAAA,gZAAAA,CAAAA,uBAAU,EAAA;cAChC,MAAA,MAAA,MAAA,UAAA;YACAM,wFAAa;YACbX,aAAAA;YACF;QAEA;QACA,MAAMY,cAAAA,CAAAA,GAAAA,qYAAAA,CAAAA,8BAAgCC,EAAAA,IAAcd,GAAAA;QAEpD,MAAMe,eAAcL,IAAIT,UAAW,GAAC,cAAA;QACpC,MAAMe,cAAcN,IAAIT,OAAO,CAACgB,GAAG,CAACC,mBAAAA;QACpC,MAAMC,YAAAA,CAAAA,CAAAA,IAAgB,OAACT,CAAAA,GAAAA,CAAAA,gZAAAA,CAAAA,2BAAgB;QACvC,MAAIU,eAAAA,CAAAA,CAAmBL,CAAAA,CAAAA,mBAAgBM,IAAAA,OAAAA,CAAAA,GAAAA,CAAAA,OAAAA,KAAAA,OAAAA,KAAAA,IAAAA,iBAAAA,QAAAA,CAAAA,gZAAAA,CAAAA,WAAAA,CAAAA;QAEvC,IAAId,mBAAYC,gBAAa,gZAAA,CAAA,0BAAc;;;;QAS3C,4FAAoE;QACpE,oEAAkC;YAChC,CAAA,oBAAA,CAAA,IAAA,EAAA,EAAA;YACA,2FAAc;gBACZM,IAAAA,IAAAA,EAAAA;gBACF,YAAA,IAAA,GAAA,IAAA,IAAA;YAEA;YACF,OAAA,gBAAA,YAAA,QAAA;QAEA;QACA,2EAEE;cACEQ,CAAAA,SAAAA,WAAAA,GAAAA,MAAAA,gBAAAA,QAAAA,OAAAA,CAAAA,MAAAA;YACF,YAAA,+XAAA,CAAA,aAAA;QAGF;YACE,mBAAOC,SAAoBC;YAC7B,OAAA,gBAAA,IAAA,GAAA;QAEA;eAAQC;YAAYZ;YAAcG;YAAWG;YAAa;SAC1D;aACAO,KAAQC;QAIR,QAAA,KAAA,CAAA,qCAAiD,MAAA,yCAAA;QACjD,iDAAA;QACA,qHAAiG;QACjG,iGAAO;eAACH;YAAgBxB,IAAAA,QAAAA;YAAW;YAAO;YAAM;SAClD;IACF"}},
    {"offset": {"line": 168, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/create-router-cache-key.ts"],"sourcesContent":["import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n"],"names":["createRouterCacheKey","segment","withoutSearchParameters","Array","isArray","startsWith","PAGE_SEGMENT_KEY"],"mappings":";;;;;;AAGO,SAASA,qBACdC,OAAgB,EAChBC,uBAAwC;IAAxCA,IAAAA,4BAAAA,KAAAA,GAAAA,0BAAmC;IAEnC,8DAA8D;IAC9D,uGAAuG;IACvG,IAAIC,MAAMC,OAAO,CAACH,UAAU;QAC1B,OAAO,OAAU,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE,GAAC,MAAGA,OAAO,CAAC,EAAE;IAClD;IAEA,kEAAkE;IAClE,kFAAkF;IAClF,IAAIC,2BAA2BD,QAAQI,UAAU,CAACC,wXAAAA,CAAAA,mBAAAA,GAAmB;QACnE,OAAOA,wXAAAA,CAAAA,mBAAAA;IACT;IAEA,OAAOL;AACT"}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightSegmentPath } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\nexport function invalidateCacheBelowFlightSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n  const [parallelRouteKey, segment] = flightSegmentPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  // In case of last entry don't copy further down.\n  if (isLastEntry) {\n    childSegmentMap.delete(cacheKey)\n    return\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      lazyDataResolved: childCacheNode.lazyDataResolved,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  invalidateCacheBelowFlightSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    flightSegmentPath.slice(2)\n  )\n}\n"],"names":["invalidateCacheBelowFlightSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","delete","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","lazyDataResolved","slice"],"mappings":";;;;;;AAOO,SAASA,sCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAChD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IAEpC,MAAMK,WAAWC,CAAAA,GAAAA,6aAAAA,CAAAA,uBAAAA,EAAqBF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAI,CAACI,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAClD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,iDAAiD;IACjD,IAAIT,aAAa;QACfS,gBAAgBG,MAAM,CAACR;QACvB;IACF;IAEA,MAAMS,yBAAyBP,wBAAwBE,GAAG,CAACJ;IAC3D,IAAIU,iBAAiBL,gBAAgBD,GAAG,CAACJ;IAEzC,IAAI,CAACU,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCZ,gBAAgB,IAAIG,IAAII,eAAeP,cAAc;YACrDa,kBAAkBN,eAAeM,gBAAgB;QACnD;QACAX,gBAAgBE,GAAG,CAACP,UAAUU;IAChC;IAEAlB,sCACEkB,gBACAD,wBACAd,kBAAkBsB,KAAK,CAAC;AAE5B"}},
    {"offset": {"line": 245, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 250, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n} from './router-reducer-types'\n\nexport function fillLazyItemsTillLeafWithHead(\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[1][key] !== undefined\n        ? cacheNodeSeedData[1][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        const hasReusablePrefetch =\n          prefetchEntry?.kind === 'auto' &&\n          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[2]\n          const loading = parallelSeedData[3]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior — no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            lazyDataResolved: false,\n          }\n        } else if (hasReusablePrefetch && existingCacheNode) {\n          // No new data was sent from the server, but the existing cache node\n          // was prefetched, so we should reuse that.\n          newCacheNode = {\n            lazyData: existingCacheNode.lazyData,\n            rsc: existingCacheNode.rsc,\n            // This is a PPR-only field. Unlike the previous branch, since we're\n            // just cloning the existing cache node, we might as well keep the\n            // PPR value, if it exists.\n            prefetchRsc: existingCacheNode.prefetchRsc,\n            head: existingCacheNode.head,\n            prefetchHead: existingCacheNode.prefetchHead,\n            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n            lazyDataResolved: existingCacheNode.lazyDataResolved,\n            loading: existingCacheNode.loading,\n          } as CacheNode\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            lazyDataResolved: false,\n            loading: null,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head,\n          prefetchEntry\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[2]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        lazyDataResolved: false,\n        loading,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        lazyDataResolved: false,\n        loading: null,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head,\n      prefetchEntry\n    )\n  }\n}\n"],"names":["fillLazyItemsTillLeafWithHead","newCache","existingCache","routerState","cacheNodeSeedData","head","prefetchEntry","isLastSegment","Object","keys","length","key","parallelRouteState","segmentForParallelRoute","cacheKey","createRouterCacheKey","parallelSeedData","undefined","existingParallelRoutesCacheNode","parallelRoutes","get","hasReusablePrefetch","kind","status","PrefetchCacheEntryStatus","reusable","parallelRouteCacheNode","Map","existingCacheNode","newCacheNode","seedNode","loading","lazyData","rsc","prefetchRsc","prefetchHead","lazyDataResolved","set","existingParallelRoutes"],"mappings":"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"}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/invalidate-cache-by-router-state.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightRouterState } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n"],"names":["invalidateCacheByRouterState","newCache","existingCache","routerState","key","segmentForParallelRoute","cacheKey","createRouterCacheKey","existingParallelRoutesCacheNode","parallelRoutes","get","parallelRouteCacheNode","Map","delete","set"],"mappings":";;;;;;AAOO,SAASA,6BACdC,QAAmB,EACnBC,aAAwB,EACxBC,WAA8B;IAE9B,uFAAuF;IACvF,IAAK,MAAMC,OAAOD,WAAW,CAAC,EAAE,CAAE;QAChC,MAAME,0BAA0BF,WAAW,CAAC,EAAE,CAACC,IAAI,CAAC,EAAE;QACtD,MAAME,WAAWC,CAAAA,GAAAA,6aAAAA,CAAAA,uBAAAA,EAAqBF;QACtC,MAAMG,kCACJN,cAAcO,cAAc,CAACC,GAAG,CAACN;QACnC,IAAII,iCAAiC;YACnC,IAAIG,yBAAyB,IAAIC,IAAIJ;YACrCG,uBAAuBE,MAAM,CAACP;YAC9BL,SAASQ,cAAc,CAACK,GAAG,CAACV,KAAKO;QACnC;IACF;AACF"}},
    {"offset": {"line": 411, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 416, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightDataPath,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightDataPath: FlightDataPath,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  const isLastEntry = flightDataPath.length <= 5\n  const [parallelRouteKey, segment] = flightDataPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      const seedData: CacheNodeSeedData = flightDataPath[3]\n      const rsc = seedData[2]\n      const loading = seedData[3]\n      childCacheNode = {\n        lazyData: null,\n        rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        loading,\n        // Ensure segments other than the one we got data for are preserved.\n        parallelRoutes: existingChildCacheNode\n          ? new Map(existingChildCacheNode.parallelRoutes)\n          : new Map(),\n        lazyDataResolved: false,\n      }\n\n      if (existingChildCacheNode) {\n        invalidateCacheByRouterState(\n          childCacheNode,\n          existingChildCacheNode,\n          flightDataPath[2]\n        )\n      }\n\n      fillLazyItemsTillLeafWithHead(\n        childCacheNode,\n        existingChildCacheNode,\n        flightDataPath[2],\n        seedData,\n        flightDataPath[4],\n        prefetchEntry\n      )\n\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      lazyDataResolved: false,\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  fillCacheWithNewSubTreeData(\n    childCacheNode,\n    existingChildCacheNode,\n    flightDataPath.slice(2),\n    prefetchEntry\n  )\n}\n"],"names":["fillCacheWithNewSubTreeData","newCache","existingCache","flightDataPath","prefetchEntry","isLastEntry","length","parallelRouteKey","segment","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","seedData","rsc","loading","prefetchRsc","head","prefetchHead","lazyDataResolved","invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","slice"],"mappings":";;;;;;;;;;AAaO,SAASA,4BACdC,QAAmB,EACnBC,aAAwB,EACxBC,cAA8B,EAC9BC,aAAkC;IAElC,MAAMC,cAAcF,eAAeG,MAAM,IAAI;IAC7C,MAAM,CAACC,kBAAkBC,QAAQ,GAAGL;IAEpC,MAAMM,WAAWC,CAAAA,GAAAA,6aAAAA,CAAAA,uBAAAA,EAAqBF;IAEtC,MAAMG,0BACJT,cAAcU,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAI,CAACI,yBAAyB;QAC5B,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIG,kBAAkBb,SAASW,cAAc,CAACC,GAAG,CAACN;IAClD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BV,SAASW,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,MAAMG,yBAAyBN,wBAAwBE,GAAG,CAACJ;IAC3D,IAAIS,iBAAiBJ,gBAAgBD,GAAG,CAACJ;IAEzC,IAAIJ,aAAa;QACf,IACE,CAACa,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACA,MAAMG,WAA8BjB,cAAc,CAAC,EAAE;YACrD,MAAMkB,MAAMD,QAAQ,CAAC,EAAE;YACvB,MAAME,UAAUF,QAAQ,CAAC,EAAE;YAC3BF,iBAAiB;gBACfC,UAAU;gBACVE;gBACAE,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdH;gBACA,oEAAoE;gBACpEV,gBAAgBK,yBACZ,IAAIF,IAAIE,uBAAuBL,cAAc,IAC7C,IAAIG;gBACRW,kBAAkB;YACpB;YAEA,IAAIT,wBAAwB;gBAC1BU,CAAAA,GAAAA,ybAAAA,CAAAA,+BAAAA,EACET,gBACAD,wBACAd,cAAc,CAAC,EAAE;YAErB;YAEAyB,CAAAA,GAAAA,kcAAAA,CAAAA,gCAAAA,EACEV,gBACAD,wBACAd,cAAc,CAAC,EAAE,EACjBiB,UACAjB,cAAc,CAAC,EAAE,EACjBC;YAGFU,gBAAgBE,GAAG,CAACP,UAAUS;QAChC;QACA;IACF;IAEA,IAAI,CAACA,kBAAkB,CAACD,wBAAwB;QAC9C,6EAA6E;QAC7E,sEAAsE;QACtE;IACF;IAEA,IAAIC,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCE,KAAKH,eAAeG,GAAG;YACvBE,aAAaL,eAAeK,WAAW;YACvCC,MAAMN,eAAeM,IAAI;YACzBC,cAAcP,eAAeO,YAAY;YACzCb,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDc,kBAAkB;YAClBJ,SAASJ,eAAeI,OAAO;QACjC;QACAR,gBAAgBE,GAAG,CAACP,UAAUS;IAChC;IAEAlB,4BACEkB,gBACAD,wBACAd,eAAe0B,KAAK,CAAC,IACrBzB;AAEJ"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 492, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/apply-flight-data.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\n\nexport function applyFlightData(\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightDataPath: FlightDataPath,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const [treePatch, cacheNodeSeedData, head] = flightDataPath.slice(-3)\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (cacheNodeSeedData === null) {\n    return false\n  }\n\n  if (flightDataPath.length === 3) {\n    const rsc = cacheNodeSeedData[2]\n    const loading = cacheNodeSeedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior — no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      existingCache,\n      treePatch,\n      cacheNodeSeedData,\n      head,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(\n      cache,\n      existingCache,\n      flightDataPath,\n      prefetchEntry\n    )\n  }\n\n  return true\n}\n"],"names":["applyFlightData","existingCache","cache","flightDataPath","prefetchEntry","treePatch","cacheNodeSeedData","head","slice","length","rsc","loading","prefetchRsc","fillLazyItemsTillLeafWithHead","parallelRoutes","Map","fillCacheWithNewSubTreeData"],"mappings":";;;;;;;;AAMO,SAASA,gBACdC,aAAwB,EACxBC,KAAgB,EAChBC,cAA8B,EAC9BC,aAAkC;IAElC,0DAA0D;IAC1D,MAAM,CAACC,WAAWC,mBAAmBC,KAAK,GAAGJ,eAAeK,KAAK,CAAC,CAAC;IAEnE,8FAA8F;IAC9F,IAAIF,sBAAsB,MAAM;QAC9B,OAAO;IACT;IAEA,IAAIH,eAAeM,MAAM,KAAK,GAAG;QAC/B,MAAMC,MAAMJ,iBAAiB,CAAC,EAAE;QAChC,MAAMK,UAAUL,iBAAiB,CAAC,EAAE;QACpCJ,MAAMS,OAAO,GAAGA;QAChBT,MAAMQ,GAAG,GAAGA;QACZ,kEAAkE;QAClE,oEAAoE;QACpE,2DAA2D;QAC3D,kEAAkE;QAClE,+BAA+B;QAC/BR,MAAMU,WAAW,GAAG;QACpBC,CAAAA,GAAAA,kcAAAA,CAAAA,gCAAAA,EACEX,OACAD,eACAI,WACAC,mBACAC,MACAH;IAEJ,OAAO;QACL,2CAA2C;QAC3CF,MAAMQ,GAAG,GAAGT,cAAcS,GAAG;QAC7B,oEAAoE;QACpE,kEAAkE;QAClE,2BAA2B;QAC3BR,MAAMU,WAAW,GAAGX,cAAcW,WAAW;QAC7CV,MAAMY,cAAc,GAAG,IAAIC,IAAId,cAAca,cAAc;QAC3DZ,MAAMS,OAAO,GAAGV,cAAcU,OAAO;QACrC,4DAA4D;QAC5DK,CAAAA,GAAAA,4bAAAA,CAAAA,8BAAAA,EACEd,OACAD,eACAE,gBACAC;IAEJ;IAEA,OAAO;AACT"}},
    {"offset": {"line": 533, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 538, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/refetch-inactive-parallel-segments.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== location.pathname + location.search &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n      // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n      [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n      includeNextUrl ? state.nextUrl : null,\n      state.buildId\n    ).then((fetchResponse) => {\n      const flightData = fetchResponse[0]\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(updatedCache, updatedCache, flightDataPath)\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n"],"names":["refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","rootTree","updatedTree","state","updatedCache","includeNextUrl","parallelRoutes","refetchPath","refetchMarker","fetchPromises","location","pathname","search","has","add","fetchPromise","fetchServerResponse","URL","origin","nextUrl","buildId","then","fetchResponse","flightData","flightDataPath","applyFlightData","push","key","parallelFetchPromise","Promise","all","addRefreshMarkerToActiveParallelSegments","tree","path","segment","includes","PAGE_SEGMENT_KEY"],"mappings":";;;;;;;;;;;AAyBO,eAAeA,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,KAUlD;IAVkD,IAAA,EACjDG,KAAK,EACLD,WAAW,EACXE,YAAY,EACZC,cAAc,EACdP,eAAe,EACfG,WAAWC,WAAW,EAIvB,GAVkD;IAWjD,MAAM,GAAGI,gBAAgBC,aAAaC,cAAc,GAAGN;IACvD,MAAMO,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBG,SAASC,QAAQ,GAAGD,SAASE,MAAM,IACnDJ,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACV,gBAAgBe,GAAG,CAACN,cACrB;QACAT,gBAAgBgB,GAAG,CAACP,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMQ,eAAeC,CAAAA,GAAAA,waAAAA,CAAAA,sBAAAA,EACnB,IAAIC,IAAIV,aAAaG,SAASQ,MAAM,GAEpC,8HAA8H;QAC9H;YAACjB,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAEA,QAAQ,CAAC,EAAE;YAAE;SAAU,EAClDI,iBAAiBF,MAAMgB,OAAO,GAAG,MACjChB,MAAMiB,OAAO,EACbC,IAAI,CAAC,CAACC;YACN,MAAMC,aAAaD,aAAa,CAAC,EAAE;YACnC,IAAI,OAAOC,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5EE,CAAAA,GAAAA,oaAAAA,CAAAA,kBAAAA,EAAgBrB,cAAcA,cAAcoB;gBAC9C;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAf,cAAciB,IAAI,CAACX;IACrB;IAEA,IAAK,MAAMY,OAAOrB,eAAgB;QAChC,MAAMsB,uBAAuB5B,oCAAoC;YAC/DG;YACAD,aAAaI,cAAc,CAACqB,IAAI;YAChCvB;YACAC;YACAP;YACAG;QACF;QAEAQ,cAAciB,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAACrB;AACpB;AAQO,SAASsB,yCACdC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAAS5B,kBAAkBE,cAAc,GAAGwB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACC,wXAAAA,CAAAA,mBAAAA,KAAqB5B,kBAAkB,WAAW;QACrEwB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAML,OAAOrB,eAAgB;QAChCyB,yCAAyCzB,cAAc,CAACqB,IAAI,EAAEM;IAChE;AACF"}},
    {"offset": {"line": 615, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/apply-router-state-patch-to-tree.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState,\n  flightSegmentPath: FlightSegmentPath\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key],\n          flightSegmentPath\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(\n      flightRouterState,\n      treePatch,\n      flightSegmentPath\n    )\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      flightSegmentPath\n    )\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      flightSegmentPath.slice(2),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n"],"names":["applyPatch","initialTree","patchTree","flightSegmentPath","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","DEFAULT_SEGMENT_KEY","matchSegment","newParallelRoutes","key","isInPatchTreeParallelRoutes","tree","applyRouterStatePatchToTree","flightRouterState","treePatch","path","segment","parallelRoutes","url","refetch","isRootLayout","length","addRefreshMarkerToActiveParallelSegments","currentSegment","parallelRouteKey","lastSegment","parallelRoutePatch","slice"],"mappings":";;;;;;;;;;AAQA;;CAEC,GACD,SAASA,WACPC,WAA8B,EAC9BC,SAA4B,EAC5BC,iBAAoC;IAEpC,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGJ;IAChD,MAAM,CAACK,cAAcC,oBAAoB,GAAGL;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEI,iBAAiBE,wXAAAA,CAAAA,sBAAAA,IACjBJ,mBAAmBI,wXAAAA,CAAAA,sBAAAA,EACnB;QACA,OAAOP;IACT;IAEA,IAAIQ,CAAAA,GAAAA,yYAAAA,CAAAA,eAAAA,EAAaL,gBAAgBE,eAAe;QAC9C,MAAMI,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAON,sBAAuB;YACvC,MAAMO,8BACJ,OAAOL,mBAAmB,CAACI,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGX,WACvBK,qBAAqB,CAACM,IAAI,EAC1BJ,mBAAmB,CAACI,IAAI,EACxBR;YAEJ,OAAO;gBACLO,iBAAiB,CAACC,IAAI,GAAGN,qBAAqB,CAACM,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOJ,oBAAqB;YACrC,IAAIG,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGJ,mBAAmB,CAACI,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACT;YAAgBM;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIT,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBY,IAAI,CAAC,EAAE,GAAGZ,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOY;IACT;IAEA,OAAOX;AACT;AAOO,SAASY,4BACdX,iBAAoC,EACpCY,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAIZ,kBAAkBoB,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0Bb,WAC9Be,mBACAC,WACAb;QAGFqB,CAAAA,GAAAA,wbAAAA,CAAAA,2CAAAA,EAAyCX,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGvB;IAE3C,iGAAiG;IACjG,IAAI,CAACM,CAAAA,GAAAA,yYAAAA,CAAAA,eAAAA,EAAagB,gBAAgBP,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMS,cAAcxB,kBAAkBoB,MAAM,KAAK;IAEjD,IAAIK;IACJ,IAAID,aAAa;QACfC,qBAAqB5B,WACnBmB,cAAc,CAACO,iBAAiB,EAChCV,WACAb;IAEJ,OAAO;QACLyB,qBAAqBd,4BACnBX,kBAAkB0B,KAAK,CAAC,IACxBV,cAAc,CAACO,iBAAiB,EAChCV,WACAC;QAGF,IAAIW,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BV,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGgB,cAAc;YACjB,CAACO,iBAAiB,EAAEE;QACtB;QACAR;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAW,CAAAA,GAAAA,wbAAAA,CAAAA,2CAAAA,EAAyCX,MAAMI;IAE/C,OAAOJ;AACT"}},
    {"offset": {"line": 713, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 718, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/should-hard-navigate.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    flightSegmentPath.slice(2),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n"],"names":["shouldHardNavigate","flightSegmentPath","flightRouterState","segment","parallelRoutes","currentSegment","parallelRouteKey","matchSegment","Array","isArray","lastSegment","length","slice"],"mappings":";;;;;;AAQO,SAASA,mBACdC,iBAAiC,EACjCC,iBAAoC;IAEpC,MAAM,CAACC,SAASC,eAAe,GAAGF;IAClC,2CAA2C;IAC3C,MAAM,CAACG,gBAAgBC,iBAAiB,GAAGL;IAK3C,yDAAyD;IACzD,IAAI,CAACM,CAAAA,GAAAA,yYAAAA,CAAAA,eAAAA,EAAaF,gBAAgBF,UAAU;QAC1C,kGAAkG;QAClG,IAAIK,MAAMC,OAAO,CAACJ,iBAAiB;YACjC,OAAO;QACT;QAEA,sEAAsE;QACtE,OAAO;IACT;IACA,MAAMK,cAAcT,kBAAkBU,MAAM,IAAI;IAEhD,IAAID,aAAa;QACf,OAAO;IACT;IAEA,OAAOV,mBACLC,kBAAkBW,KAAK,CAAC,IACxBR,cAAc,CAACE,iBAAiB;AAEpC"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/is-navigating-to-new-root-layout.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree  didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n"],"names":["isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","Object","values","nextTreeChild"],"mappings":";;;AAEO,SAASA,4BACdC,WAA8B,EAC9BC,QAA2B;IAE3B,mBAAmB;IACnB,MAAMC,qBAAqBF,WAAW,CAAC,EAAE;IACzC,MAAMG,kBAAkBF,QAAQ,CAAC,EAAE;IAEnC,2FAA2F;IAC3F,4DAA4D;IAC5D,uIAAuI;IACvI,IAAIG,MAAMC,OAAO,CAACH,uBAAuBE,MAAMC,OAAO,CAACF,kBAAkB;QACvE,sHAAsH;QACtH,uGAAuG;QACvG,IACED,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,IAC5CD,kBAAkB,CAAC,EAAE,KAAKC,eAAe,CAAC,EAAE,EAC5C;YACA,OAAO;QACT;IACF,OAAO,IAAID,uBAAuBC,iBAAiB;QACjD,OAAO;IACT;IAEA,iCAAiC;IACjC,IAAIH,WAAW,CAAC,EAAE,EAAE;QAClB,4EAA4E;QAC5E,OAAO,CAACC,QAAQ,CAAC,EAAE;IACrB;IACA,qEAAqE;IACrE,IAAIA,QAAQ,CAAC,EAAE,EAAE;QACf,OAAO;IACT;IACA,4GAA4G;IAC5G,2FAA2F;IAC3F,mDAAmD;IACnD,MAAMK,mBAAmBC,OAAOC,MAAM,CAACR,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE;IACzD,MAAMS,gBAAgBF,OAAOC,MAAM,CAACP,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAE;IACnD,IAAI,CAACK,oBAAoB,CAACG,eAAe,OAAO;IAChD,OAAOV,4BAA4BO,kBAAkBG;AACvD"}},
    {"offset": {"line": 784, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/compute-changed-path.ts"],"sourcesContent":["import type {\n  FlightRouterState,\n  Segment,\n} from '../../../server/app-render/types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../server/future/helpers/interception-routes'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n"],"names":["removeLeadingSlash","segment","slice","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","extractPathFromFlightRouterState","flightRouterState","Array","isArray","DEFAULT_SEGMENT_KEY","INTERCEPTION_ROUTE_MARKERS","some","m","startsWith","undefined","PAGE_SEGMENT_KEY","parallelRoutes","childrenPath","children","push","key","value","Object","entries","childPath","computeChangedPathImpl","treeA","treeB","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","matchSegment","parallelRouterKey","changedPath","computeChangedPath","split"],"mappings":"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"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 880, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/handle-mutable.ts"],"sourcesContent":["import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    buildId: state.buildId,\n    // Set href.\n    canonicalUrl: isNotUndefined(mutable.canonicalUrl)\n      ? mutable.canonicalUrl === state.canonicalUrl\n        ? state.canonicalUrl\n        : mutable.canonicalUrl\n      : state.canonicalUrl,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange:\n        !!mutable.hashFragment &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          mutable.canonicalUrl?.split('#', 1)[0],\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    prefetchCache: mutable.prefetchCache\n      ? mutable.prefetchCache\n      : state.prefetchCache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n  }\n}\n"],"names":["isNotUndefined","value","handleMutable","state","mutable","shouldScroll","nextUrl","patchedTree","changedPath","computeChangedPath","tree","canonicalUrl","buildId","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","split","decodeURIComponent","slice","segmentPaths","cache","prefetchCache"],"mappings":";;;;;;AAOA,SAASA,eAAkBC,KAAQ;IACjC,OAAO,OAAOA,UAAU;AAC1B;AAEO,SAASC,cACdC,KAA2B,EAC3BC,OAAgB;QAoDRA;QAjDaA;IADrB,0DAA0D;IAC1D,MAAMC,eAAeD,CAAAA,wBAAAA,QAAQC,YAAY,KAAA,OAApBD,wBAAwB;IAE7C,IAAIE,UAAUH,MAAMG,OAAO;IAE3B,IAAIN,eAAeI,QAAQG,WAAW,GAAG;QACvC,sEAAsE;QACtE,MAAMC,cAAcC,CAAAA,GAAAA,uaAAAA,CAAAA,qBAAAA,EAAmBN,MAAMO,IAAI,EAAEN,QAAQG,WAAW;QACtE,IAAIC,aAAa;YACf,qDAAqD;YACrDF,UAAUE;QACZ,OAAO,IAAI,CAACF,SAAS;YACnB,6HAA6H;YAC7HA,UAAUH,MAAMQ,YAAY;QAC9B;IACA,0EAA0E;IAC5E;QA6CQP;IA3CR,OAAO;QACLQ,SAAST,MAAMS,OAAO;QACtB,YAAY;QACZD,cAAcX,eAAeI,QAAQO,YAAY,IAC7CP,QAAQO,YAAY,KAAKR,MAAMQ,YAAY,GACzCR,MAAMQ,YAAY,GAClBP,QAAQO,YAAY,GACtBR,MAAMQ,YAAY;QACtBE,SAAS;YACPC,aAAad,eAAeI,QAAQU,WAAW,IAC3CV,QAAQU,WAAW,GACnBX,MAAMU,OAAO,CAACC,WAAW;YAC7BC,eAAef,eAAeI,QAAQW,aAAa,IAC/CX,QAAQW,aAAa,GACrBZ,MAAMU,OAAO,CAACE,aAAa;YAC/BC,4BAA4BhB,eAC1BI,QAAQY,0BAA0B,IAEhCZ,QAAQY,0BAA0B,GAClCb,MAAMU,OAAO,CAACG,0BAA0B;QAC9C;QACA,kEAAkE;QAClEC,mBAAmB;YACjBC,OAAOb,eACHL,eAAeI,WAAAA,OAAAA,KAAAA,IAAAA,QAASe,kBAAkB,IACxC,OACAhB,MAAMc,iBAAiB,CAACC,KAAK,GAE/B;YACJE,gBACE,CAAC,CAAChB,QAAQiB,YAAY,IACtBlB,MAAMQ,YAAY,CAACW,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE,KAAA,CAAA,CACjClB,wBAAAA,QAAQO,YAAY,KAAA,OAAA,KAAA,IAApBP,sBAAsBkB,KAAK,CAAC,KAAK,EAAE,CAAC,EAAE;YAC1CD,cAAchB,eAGVD,QAAQiB,YAAY,IAAIjB,QAAQiB,YAAY,KAAK,KAE/CE,mBAAmBnB,QAAQiB,YAAY,CAACG,KAAK,CAAC,MAC9CrB,MAAMc,iBAAiB,CAACI,YAAY,GAEtC;YACJI,cAAcpB,eACVD,CAAAA,8BAAAA,WAAAA,OAAAA,KAAAA,IAAAA,QAASe,kBAAkB,KAAA,OAA3Bf,8BAA+BD,MAAMc,iBAAiB,CAACQ,YAAY,GAEnE,EAAE;QACR;QACA,eAAe;QACfC,OAAOtB,QAAQsB,KAAK,GAAGtB,QAAQsB,KAAK,GAAGvB,MAAMuB,KAAK;QAClDC,eAAevB,QAAQuB,aAAa,GAChCvB,QAAQuB,aAAa,GACrBxB,MAAMwB,aAAa;QACvB,8BAA8B;QAC9BjB,MAAMV,eAAeI,QAAQG,WAAW,IACpCH,QAAQG,WAAW,GACnBJ,MAAMO,IAAI;QACdJ;IACF;AACF"}},
    {"offset": {"line": 932, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 937, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/prefetch-cache-utils.ts"],"sourcesContent":["import { createHrefFromUrl } from './create-href-from-url'\nimport {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKey(url: URL, nextUrl?: string | null) {\n  const pathnameFromUrl = createHrefFromUrl(\n    url,\n    // Ensures the hash is not part of the cache key as it does not impact the server fetch\n    false\n  )\n\n  // nextUrl is used as a cache key delimiter since entries can vary based on the Next-URL header\n  if (nextUrl) {\n    return `${nextUrl}%${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  buildId,\n  prefetchCache,\n  kind,\n}: Pick<\n  ReadonlyReducerState,\n  'nextUrl' | 'prefetchCache' | 'tree' | 'buildId'\n> & {\n  url: URL\n  kind?: PrefetchKind\n}): PrefetchCacheEntry {\n  let existingCacheEntry: PrefetchCacheEntry | undefined = undefined\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  const interceptionCacheKey = createPrefetchCacheKey(url, nextUrl)\n  const interceptionData = prefetchCache.get(interceptionCacheKey)\n\n  if (interceptionData) {\n    existingCacheEntry = interceptionData\n  } else {\n    // If we dont find a more specific interception route prefetch entry, we check for a regular prefetch entry\n    const prefetchCacheKey = createPrefetchCacheKey(url)\n    const prefetchData = prefetchCache.get(prefetchCacheKey)\n    if (prefetchData) {\n      existingCacheEntry = prefetchData\n    }\n  }\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      return createLazyPrefetchEntry({\n        tree,\n        url,\n        buildId,\n        nextUrl,\n        prefetchCache,\n        // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n        // rather than assuming the same intent as the previous entry, to be consistent with how we\n        // lazily create prefetch entries when intent is left unspecified.\n        kind: kind ?? PrefetchKind.TEMPORARY,\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    buildId,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n}) {\n  const existingCacheKey = createPrefetchCacheKey(url)\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(url, nextUrl)\n  prefetchCache.set(newCacheKey, existingCacheEntry)\n  prefetchCache.delete(existingCacheKey)\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createPrefetchCacheEntryForInitialLoad({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  kind,\n  data,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n  data: FetchServerResponseResult\n}) {\n  const [, , , intercept] = data\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = intercept\n    ? createPrefetchCacheKey(url, nextUrl)\n    : createPrefetchCacheKey(url)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  buildId,\n  prefetchCache,\n}: Pick<\n  ReadonlyReducerState,\n  'nextUrl' | 'tree' | 'buildId' | 'prefetchCache'\n> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, tree, nextUrl, buildId, kind).then(\n      (prefetchResponse) => {\n        // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n        // to avoid drift between this cache key prefixing logic\n        // (which is currently directly influenced by the server response)\n        const [, , , intercepted] = prefetchResponse\n        if (intercepted) {\n          prefixExistingPrefetchCacheEntry({ url, nextUrl, prefetchCache })\n        }\n\n        return prefetchResponse\n      }\n    )\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 30 seconds (dynamic)\nconst DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nconst STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === 'auto') {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === 'full') {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n"],"names":["createPrefetchCacheKey","url","nextUrl","pathnameFromUrl","createHrefFromUrl","getOrCreatePrefetchCacheEntry","tree","buildId","prefetchCache","kind","existingCacheEntry","undefined","interceptionCacheKey","interceptionData","get","prefetchCacheKey","prefetchData","status","getPrefetchEntryCacheStatus","switchedToFullPrefetch","PrefetchKind","FULL","createLazyPrefetchEntry","TEMPORARY","prefixExistingPrefetchCacheEntry","existingCacheKey","newCacheKey","set","delete","createPrefetchCacheEntryForInitialLoad","data","intercept","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","key","PrefetchCacheEntryStatus","fresh","prefetchQueue","enqueue","fetchServerResponse","then","prefetchResponse","intercepted","prunePrefetchCache","href","prefetchCacheEntry","expired","DYNAMIC_STALETIME_MS","Number","STATIC_STALETIME_MS","reusable","stale"],"mappings":"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"}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1123, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/prefetch-reducer.ts"],"sourcesContent":["import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { NEXT_RSC_UNION_QUERY } from '../../app-router-headers'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\n\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport function prefetchReducer(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n  url.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    buildId: state.buildId,\n  })\n\n  return state\n}\n"],"names":["prefetchQueue","PromiseQueue","prefetchReducer","state","action","prunePrefetchCache","prefetchCache","url","searchParams","delete","NEXT_RSC_UNION_QUERY","getOrCreatePrefetchCacheEntry","nextUrl","kind","tree","buildId"],"mappings":";;;;;;;;;;;AAYO,MAAMA,gBAAgB,IAAIC,wYAAAA,CAAAA,eAAAA,CAAa;AAEvC,SAASC,gBACdC,KAA2B,EAC3BC,MAAsB;IAEtB,4DAA4D;IAC5DC,CAAAA,GAAAA,uaAAAA,CAAAA,qBAAAA,EAAmBF,MAAMG,aAAa;IAEtC,MAAM,EAAEC,GAAG,EAAE,GAAGH;IAChBG,IAAIC,YAAY,CAACC,MAAM,CAACC,gZAAAA,CAAAA,uBAAAA;IAExBC,CAAAA,GAAAA,uaAAAA,CAAAA,gCAAAA,EAA8B;QAC5BJ;QACAK,SAAST,MAAMS,OAAO;QACtBN,eAAeH,MAAMG,aAAa;QAClCO,MAAMT,OAAOS,IAAI;QACjBC,MAAMX,MAAMW,IAAI;QAChBC,SAASZ,MAAMY,OAAO;IACxB;IAEA,OAAOZ;AACT"}},
    {"offset": {"line": 1150, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1155, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype Task = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // This is usually non-null. It represents a brand new Cache Node tree whose\n  // data is still pending. If it's null, it means there's no pending data but\n  // the client patched the router state.\n  node: CacheNode | null\n  children: Map<string, Task> | null\n}\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function updateCacheNodeOnNavigation(\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData,\n  prefetchHead: React.ReactNode\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData[1]\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren[parallelRouteKey]\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === PAGE_SEGMENT_KEY) {\n      // This is a leaf segment — a page, not a shared layout. We always apply\n      // its data.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead\n      )\n    } else if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead\n        )\n      }\n    } else if (\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees.\n        if (prefetchDataChild !== undefined && prefetchDataChild !== null) {\n          // Recursively update the children.\n          taskChild = updateCacheNodeOnNavigation(\n            oldCacheNodeChild,\n            oldRouterStateChild,\n            newRouterStateChild,\n            prefetchDataChild,\n            prefetchHead\n          )\n        } else {\n          // The server didn't send any prefetch data for this segment. This\n          // shouldn't happen because the Route Tree and the Seed Data tree\n          // should always be the same shape, but until we unify those types\n          // it's still possible. For now we're going to deopt and trigger a\n          // lazy fetch during render.\n          taskChild = spawnTaskForMissingData(newRouterStateChild)\n        }\n      } else {\n        // Either there's no existing Cache Node for this segment, or this\n        // segment doesn't exist in the old Router State tree. Switch to the\n        // \"create\" path.\n        taskChild = spawnPendingTask(\n          newRouterStateChild,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = spawnPendingTask(\n        newRouterStateChild,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead\n      )\n    }\n\n    if (taskChild !== null) {\n      // Something changed in the child tree. Keep track of the child task.\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      patchedRouterStateChildren[parallelRouteKey] = taskChild.route\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n    lazyDataResolved: false,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode\n): Task {\n  // Create a task that will later be fulfilled by data from the server.\n  const pendingCacheNode = createPendingCacheNode(\n    routerState,\n    prefetchData,\n    prefetchHead\n  )\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    children: null,\n  }\n}\n\nfunction spawnTaskForMissingData(routerState: FlightRouterState): Task {\n  // Create a task for a new subtree that wasn't prefetched by the server.\n  // This shouldn't really ever happen but it's here just in case the Seed Data\n  // Tree and the Router State Tree disagree unexpectedly.\n  const pendingCacheNode = createPendingCacheNode(routerState, null, null)\n  return {\n    route: routerState,\n    node: pendingCacheNode,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: Task,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    (response: FetchServerResponseResult) => {\n      const flightData = response[0]\n      for (const flightDataPath of flightData) {\n        const segmentPath = flightDataPath.slice(0, -3)\n        const serverRouterState = flightDataPath[flightDataPath.length - 3]\n        const dynamicData = flightDataPath[flightDataPath.length - 2]\n        const dynamicHead = flightDataPath[flightDataPath.length - 1]\n\n        if (typeof segmentPath === 'string') {\n          // Happens when navigating to page in `pages` from `app`. We shouldn't\n          // get here because should have already handled this during\n          // the prefetch.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: Task,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: Task,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n) {\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Null this out to indicate that the task is complete.\n      task.node = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[1]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: React.ReactNode\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[2] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : null,\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n    lazyDataResolved: false,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: React.ReactNode\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[1]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[2]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: Task, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Null this out to indicate that the task is complete.\n  task.node = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n) {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch  data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : null,\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: shouldUsePrefetch ? oldCacheNode.loading : null,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n    lazyDataResolved: false,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["updateCacheNodeOnNavigation","oldCacheNode","oldRouterState","newRouterState","prefetchData","prefetchHead","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","oldParallelRoutes","parallelRoutes","prefetchParallelRoutes","Map","patchedRouterStateChildren","taskChildren","parallelRouteKey","newRouterStateChild","oldRouterStateChild","oldSegmentMapChild","get","prefetchDataChild","newSegmentChild","newSegmentKeyChild","createRouterCacheKey","oldSegmentChild","undefined","oldCacheNodeChild","taskChild","PAGE_SEGMENT_KEY","spawnPendingTask","DEFAULT_SEGMENT_KEY","spawnReusedTask","matchSegment","spawnTaskForMissingData","set","newCacheNodeChild","node","newSegmentMapChild","route","newCacheNode","lazyData","rsc","prefetchRsc","head","loading","lazyDataResolved","patchRouterStateWithNewChildren","children","baseRouterState","newChildren","clone","routerState","pendingCacheNode","createPendingCacheNode","reusedRouterState","listenForDynamicRequest","task","responsePromise","then","response","flightData","flightDataPath","segmentPath","slice","serverRouterState","length","dynamicData","dynamicHead","writeDynamicDataIntoPendingTask","abortTask","error","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","routerStateChildren","routerStateChild","segmentChild","segmentKeyChild","isLeafSegment","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","isDeferredRsc","resolve","values","reject","updateCacheNodeOnPopstateRestoration","newParallelRoutes","shouldUsePrefetch","status","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"mappings":"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"}},
    {"offset": {"line": 1695, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1700, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts"],"sourcesContent":["import type { FlightSegmentPath } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n */\nexport function clearCacheNodeDataForSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n\n  const [parallelRouteKey, segment] = flightSegmentPath\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  // In case of last segment start off the fetch at this level and don't copy further down.\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        lazyDataResolved: false,\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        lazyDataResolved: false,\n        loading: null,\n      })\n    }\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      lazyDataResolved: childCacheNode.lazyDataResolved,\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  return clearCacheNodeDataForSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    flightSegmentPath.slice(2)\n  )\n}\n"],"names":["clearCacheNodeDataForSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","lazyDataResolved","loading","slice"],"mappings":";;;;;;AAOO,SAASA,iCACdC,QAAmB,EACnBC,aAAwB,EACxBC,iBAAoC;IAEpC,MAAMC,cAAcD,kBAAkBE,MAAM,IAAI;IAEhD,MAAM,CAACC,kBAAkBC,QAAQ,GAAGJ;IACpC,MAAMK,WAAWC,CAAAA,GAAAA,6aAAAA,CAAAA,uBAAAA,EAAqBF;IAEtC,MAAMG,0BACJR,cAAcS,cAAc,CAACC,GAAG,CAACN;IAEnC,IAAIO,kBAAkBZ,SAASU,cAAc,CAACC,GAAG,CAACN;IAElD,IAAI,CAACO,mBAAmBA,oBAAoBH,yBAAyB;QACnEG,kBAAkB,IAAIC,IAAIJ;QAC1BT,SAASU,cAAc,CAACI,GAAG,CAACT,kBAAkBO;IAChD;IAEA,MAAMG,yBAAyBN,2BAAAA,OAAAA,KAAAA,IAAAA,wBAAyBE,GAAG,CAACJ;IAC5D,IAAIS,iBAAiBJ,gBAAgBD,GAAG,CAACJ;IAEzC,yFAAyF;IACzF,IAAIJ,aAAa;QACf,IACE,CAACa,kBACD,CAACA,eAAeC,QAAQ,IACxBD,mBAAmBD,wBACnB;YACAH,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,kBAAkB;gBAClBC,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAI,CAACP,kBAAkB,CAACD,wBAAwB;QAC9C,+EAA+E;QAC/E,IAAI,CAACC,gBAAgB;YACnBJ,gBAAgBE,GAAG,CAACP,UAAU;gBAC5BU,UAAU;gBACVC,KAAK;gBACLC,aAAa;gBACbC,MAAM;gBACNC,cAAc;gBACdX,gBAAgB,IAAIG;gBACpBS,kBAAkB;gBAClBC,SAAS;YACX;QACF;QACA;IACF;IAEA,IAAIP,mBAAmBD,wBAAwB;QAC7CC,iBAAiB;YACfC,UAAUD,eAAeC,QAAQ;YACjCC,KAAKF,eAAeE,GAAG;YACvBC,aAAaH,eAAeG,WAAW;YACvCC,MAAMJ,eAAeI,IAAI;YACzBC,cAAcL,eAAeK,YAAY;YACzCX,gBAAgB,IAAIG,IAAIG,eAAeN,cAAc;YACrDY,kBAAkBN,eAAeM,gBAAgB;YACjDC,SAASP,eAAeO,OAAO;QACjC;QACAX,gBAAgBE,GAAG,CAACP,UAAUS;IAChC;IAEA,OAAOjB,iCACLiB,gBACAD,wBACAb,kBAAkBsB,KAAK,CAAC;AAE5B"}},
    {"offset": {"line": 1765, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1770, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/navigate-reducer.ts"],"sourcesContent":["import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport {\n  listenForDynamicRequest,\n  updateCacheNodeOnNavigation,\n} from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nfunction generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\n// These implementations are expected to diverge significantly, so I've forked\n// the entire function. The one that's disabled should be dead code eliminated\n// because the check here is statically inlined at build time.\nexport const navigateReducer = process.env.__NEXT_PPR\n  ? navigateReducer_PPR\n  : navigateReducer_noPPR\n\n// This is the implementation when PPR is disabled. We can assume its behavior\n// is relatively stable because it's been running in production for a while.\nfunction navigateReducer_noPPR(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    buildId: state.buildId,\n    prefetchCache: state.prefetchCache,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ([flightData, canonicalUrlOverride]) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n      // which will trigger an MPA navigation.\n      if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush)\n      }\n\n      let currentTree = state.tree\n      const currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const flightDataPath of flightData) {\n        const flightSegmentPath = flightDataPath.slice(\n          0,\n          -4\n        ) as unknown as FlightSegmentPath\n        // The one before last item is the router state tree patch\n        const treePatch = flightDataPath.slice(-3)[0] as FlightRouterState\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          const cache: CacheNode = createEmptyCacheNode()\n          let applied = false\n\n          if (\n            prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n            !isFirstRead\n          ) {\n            // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n            // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n            // while copying over the `loading` for the segment that contains the page data.\n            // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n            applied = triggerLazyFetchForLeafSegments(\n              cache,\n              currentCache,\n              flightSegmentPath,\n              treePatch\n            )\n            // since we re-used the stale cache's loading state & refreshed the data,\n            // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n            prefetchValues.lastUsedTime = Date.now()\n          } else {\n            applied = applyFlightData(\n              currentCache,\n              cache,\n              flightDataPath,\n              prefetchValues\n            )\n          }\n\n          const hardNavigate = shouldHardNavigate(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            currentTree\n          )\n\n          if (hardNavigate) {\n            // Copy rsc for the root node of the cache.\n            cache.rsc = currentCache.rsc\n            cache.prefetchRsc = currentCache.prefetchRsc\n\n            invalidateCacheBelowFlightSegmentPath(\n              cache,\n              currentCache,\n              flightSegmentPath\n            )\n            // Ensure the existing cache value is used when the cache was not invalidated.\n            mutable.cache = cache\n          } else if (applied) {\n            mutable.cache = cache\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n      mutable.pendingPush = pendingPush\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\n// This is the experimental PPR implementation. It's closer to the behavior we\n// want, but is likelier to include accidental regressions because it rewrites\n// existing functionality.\nfunction navigateReducer_PPR(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll } = action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    buildId: state.buildId,\n    prefetchCache: state.prefetchCache,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ([flightData, canonicalUrlOverride, _postponed]) => {\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = Date.now()\n        isFirstRead = true\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n      // which will trigger an MPA navigation.\n      if (document.getElementById('__next-page-redirect')) {\n        return handleExternalUrl(state, mutable, href, pendingPush)\n      }\n\n      let currentTree = state.tree\n      const currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      // TODO: In practice, this is always a single item array. We probably\n      // aren't going to every send multiple segments, at least not in this\n      // format. So we could remove the extra wrapper for now until\n      // that settles.\n      for (const flightDataPath of flightData) {\n        const flightSegmentPath = flightDataPath.slice(\n          0,\n          -4\n        ) as unknown as FlightSegmentPath\n        // The one before last item is the router state tree patch\n        const treePatch = flightDataPath.slice(-3)[0] as FlightRouterState\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n            return handleExternalUrl(state, mutable, href, pendingPush)\n          }\n\n          if (\n            // This is just a paranoid check. When PPR is enabled, the server\n            // will always send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via updateCacheNodeOnNavigation. The current structure is just\n            // an incremental step.\n            flightDataPath.length === 3\n          ) {\n            const prefetchedTree: FlightRouterState = flightDataPath[0]\n            const seedData = flightDataPath[1]\n            const head = flightDataPath[2]\n\n            const task = updateCacheNodeOnNavigation(\n              currentCache,\n              currentTree,\n              prefetchedTree,\n              seedData,\n              head\n            )\n            if (task !== null && task.node !== null) {\n              // We've created a new Cache Node tree that contains a prefetched\n              // version of the next page. This can be rendered instantly.\n\n              // Use the tree computed by updateCacheNodeOnNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n\n              // The prefetched tree has dynamic holes in it. We initiate a\n              // dynamic request to fill them in.\n              //\n              // Do not block on the result. We'll immediately render the Cache\n              // Node tree and suspend on the dynamic parts. When the request\n              // comes in, we'll fill in missing data and ping React to\n              // re-render. Unlike the lazy fetching model in the non-PPR\n              // implementation, this is modeled as a single React update +\n              // streaming, rather than multiple top-level updates. (However,\n              // even in the new model, we'll still need to sometimes update the\n              // root multiple times per navigation, like if the server sends us\n              // a different response than we expected. For now, we revert back\n              // to the lazy fetching mechanism in that case.)\n              listenForDynamicRequest(\n                task,\n                fetchServerResponse(\n                  url,\n                  currentTree,\n                  state.nextUrl,\n                  state.buildId\n                )\n              )\n\n              mutable.cache = newCache\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = prefetchedTree\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = Date.now()\n            } else {\n              applied = applyFlightData(\n                currentCache,\n                cache,\n                flightDataPath,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n            }\n          }\n\n          currentTree = newTree\n\n          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n            if (\n              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n              DEFAULT_SEGMENT_KEY\n            ) {\n              scrollableSegments.push(scrollableSegmentPath)\n            }\n          }\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n      mutable.pendingPush = pendingPush\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["handleExternalUrl","state","mutable","url","pendingPush","mpaNavigation","canonicalUrl","scrollableSegments","undefined","handleMutable","generateSegmentsFromPatch","flightRouterPatch","segments","segment","parallelRoutes","Object","keys","length","parallelRouteKey","parallelRoute","entries","childSegment","push","triggerLazyFetchForLeafSegments","newCache","currentCache","flightSegmentPath","treePatch","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","clearCacheNodeDataForSegmentPath","navigateReducer","process","navigateReducer_PPR","navigateReducer_noPPR","action","isExternalUrl","navigateType","shouldScroll","hash","href","createHrefFromUrl","prunePrefetchCache","prefetchCache","preserveCustomHistoryState","toString","prefetchValues","getOrCreatePrefetchCacheEntry","nextUrl","tree","buildId","treeAtTimeOfPrefetch","data","prefetchQueue","bump","then","flightData","canonicalUrlOverride","isFirstRead","lastUsedTime","Date","now","document","getElementById","currentTree","cache","flightDataPath","slice","flightSegmentPathWithLeadingEmpty","newTree","applyRouterStatePatchToTree","isNavigatingToNewRootLayout","createEmptyCacheNode","applied","status","PrefetchCacheEntryStatus","stale","applyFlightData","hardNavigate","shouldHardNavigate","invalidateCacheBelowFlightSegmentPath","subSegment","scrollableSegmentPath","DEFAULT_SEGMENT_KEY","patchedTree","hashFragment","_postponed","prefetchedTree","seedData","head","task","updateCacheNodeOnNavigation","node","patchedRouterState","route","listenForDynamicRequest","fetchServerResponse"],"mappings":"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"}},
    {"offset": {"line": 2137, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2142, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/handle-segment-mismatch.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../server/app-render/types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n"],"names":["handleSegmentMismatch","state","action","treePatch","console","warn","type","JSON","stringify","tree","handleExternalUrl","canonicalUrl"],"mappings":";;;;;;AAWO,SAASA,sBACdC,KAA2B,EAC3BC,MAAsB,EACtBC,SAA4B;IAE5B,wCAA4C;QAC1CC,QAAQC,IAAI,CACV,sJACE,+BACA,CAAA,kBAAgBH,OAAOI,IAAI,GAAC,MAAI,IAChC,CAAA,mBAAiBC,KAAKC,SAAS,CAACP,MAAMQ,IAAI,IAAE,MAAI,IAChD,CAAA,yBAAuBF,KAAKC,SAAS,CAACL,UAAW;IAEvD;IAEA,OAAOO,CAAAA,GAAAA,4aAAAA,CAAAA,oBAAAA,EAAkBT,OAAO,CAAC,GAAGA,MAAMU,YAAY,EAAE;AAC1D"}},
    {"offset": {"line": 2154, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2159, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/server-patch-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const { serverResponse } = action\n  const [flightData, overrideCanonicalUrl] = serverResponse\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const flightDataPath of flightData) {\n    // Slices off the last segment (which is at -4) as it doesn't exist in the tree yet\n    const flightSegmentPath = flightDataPath.slice(0, -4)\n\n    const [treePatch] = flightDataPath.slice(-3, -2)\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    if (newTree === null) {\n      return handleSegmentMismatch(state, action, treePatch)\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = overrideCanonicalUrl\n      ? createHrefFromUrl(overrideCanonicalUrl)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(currentCache, cache, flightDataPath)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n"],"names":["serverPatchReducer","state","action","serverResponse","flightData","overrideCanonicalUrl","mutable","preserveCustomHistoryState","handleExternalUrl","pushRef","pendingPush","currentTree","tree","currentCache","cache","flightDataPath","flightSegmentPath","slice","treePatch","newTree","applyRouterStatePatchToTree","canonicalUrl","handleSegmentMismatch","isNavigatingToNewRootLayout","canonicalUrlOverrideHref","createHrefFromUrl","undefined","createEmptyCacheNode","applyFlightData","patchedTree","handleMutable"],"mappings":";;;;;;;;;;;;;;;;;;;;AAgBO,SAASA,mBACdC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,cAAc,EAAE,GAAGD;IAC3B,MAAM,CAACE,YAAYC,qBAAqB,GAAGF;IAE3C,MAAMG,UAAmB,CAAC;IAE1BA,QAAQC,0BAA0B,GAAG;IAErC,4DAA4D;IAC5D,IAAI,OAAOH,eAAe,UAAU;QAClC,OAAOI,CAAAA,GAAAA,4aAAAA,CAAAA,oBAAAA,EACLP,OACAK,SACAF,YACAH,MAAMQ,OAAO,CAACC,WAAW;IAE7B;IAEA,IAAIC,cAAcV,MAAMW,IAAI;IAC5B,IAAIC,eAAeZ,MAAMa,KAAK;IAE9B,KAAK,MAAMC,kBAAkBX,WAAY;QACvC,mFAAmF;QACnF,MAAMY,oBAAoBD,eAAeE,KAAK,CAAC,GAAG,CAAC;QAEnD,MAAM,CAACC,UAAU,GAAGH,eAAeE,KAAK,CAAC,CAAC,GAAG,CAAC;QAC9C,MAAME,UAAUC,CAAAA,GAAAA,4bAAAA,CAAAA,8BAAAA,EAEd;YAAC;eAAOJ;SAAkB,EAC1BL,aACAO,WACAjB,MAAMoB,YAAY;QAGpB,IAAIF,YAAY,MAAM;YACpB,OAAOG,CAAAA,GAAAA,0aAAAA,CAAAA,wBAAAA,EAAsBrB,OAAOC,QAAQgB;QAC9C;QAEA,IAAIK,CAAAA,GAAAA,4bAAAA,CAAAA,8BAAAA,EAA4BZ,aAAaQ,UAAU;YACrD,OAAOX,CAAAA,GAAAA,4aAAAA,CAAAA,oBAAAA,EACLP,OACAK,SACAL,MAAMoB,YAAY,EAClBpB,MAAMQ,OAAO,CAACC,WAAW;QAE7B;QAEA,MAAMc,2BAA2BnB,uBAC7BoB,CAAAA,GAAAA,0aAAAA,CAAAA,oBAAAA,EAAkBpB,wBAClBqB;QAEJ,IAAIF,0BAA0B;YAC5BlB,QAAQe,YAAY,GAAGG;QACzB;QAEA,MAAMV,QAAmBa,CAAAA,GAAAA,qYAAAA,CAAAA,uBAAAA;QACzBC,CAAAA,GAAAA,oaAAAA,CAAAA,kBAAAA,EAAgBf,cAAcC,OAAOC;QAErCT,QAAQuB,WAAW,GAAGV;QACtBb,QAAQQ,KAAK,GAAGA;QAEhBD,eAAeC;QACfH,cAAcQ;IAChB;IAEA,OAAOW,CAAAA,GAAAA,8ZAAAA,CAAAA,gBAAAA,EAAc7B,OAAOK;AAC9B"}},
    {"offset": {"line": 2217, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2222, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/restore-reducer.ts"],"sourcesContent":["import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    buildId: state.buildId,\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n"],"names":["restoreReducer","state","action","url","tree","href","createHrefFromUrl","treeToRestore","oldCache","cache","newCache","process","updateCacheNodeOnPopstateRestoration","extractPathFromFlightRouterState","buildId","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","prefetchCache","nextUrl","pathname"],"mappings":";;;;;;;;;;AASO,SAASA,eACdC,KAA2B,EAC3BC,MAAqB;IAErB,MAAM,EAAEC,GAAG,EAAEC,IAAI,EAAE,GAAGF;IACtB,MAAMG,OAAOC,CAAAA,GAAAA,0aAAAA,CAAAA,oBAAAA,EAAkBH;IAC/B,0EAA0E;IAC1E,4FAA4F;IAC5F,gGAAgG;IAChG,6FAA6F;IAC7F,8DAA8D;IAC9D,yGAAyG;IACzG,MAAMI,gBAAgBH,QAAQH,MAAMG,IAAI;IAExC,MAAMI,WAAWP,MAAMQ,KAAK;IAC5B,MAAMC,WAAWC,uCAGb,2DAA2D;IAC3D,2BAA2B;IAC3BC,CAAAA,GAAAA,+ZAAAA,CAAAA,uCAAAA,EAAqCJ,UAAUD;QAkBxCM;IAfX,OAAO;QACLC,SAASb,MAAMa,OAAO;QACtB,oBAAoB;QACpBC,cAAcV;QACdW,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,6FAA6F;YAC7FC,4BAA4B;QAC9B;QACAC,mBAAmBnB,MAAMmB,iBAAiB;QAC1CX,OAAOC;QACPW,eAAepB,MAAMoB,aAAa;QAClC,wBAAwB;QACxBjB,MAAMG;QACNe,SAAST,CAAAA,oCAAAA,CAAAA,GAAAA,uaAAAA,CAAAA,mCAAAA,EAAiCN,cAAAA,KAAAA,OAAjCM,oCAAmDV,IAAIoB,QAAQ;IAC1E;AACF"}},
    {"offset": {"line": 2265, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2270, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../server/future/helpers/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["hasInterceptionRouteInCurrentTree","segment","parallelRoutes","Array","isArray","isInterceptionRouteAppPath","key"],"mappings":";;;;;;AAGO,SAASA,kCAAkC,KAG9B;IAH8B,IAAA,CAChDC,SACAC,eACkB,GAH8B;IAIhD,wGAAwG;IACxG,IAAIC,MAAMC,OAAO,CAACH,YAAaA,CAAAA,OAAO,CAAC,EAAE,KAAK,QAAQA,OAAO,CAAC,EAAE,KAAK,IAAG,GAAI;QAC1E,OAAO;IACT;IAEA,oEAAoE;IACpE,IAAI,OAAOA,YAAY,YAAYI,CAAAA,GAAAA,qZAAAA,CAAAA,6BAAAA,EAA2BJ,UAAU;QACtE,OAAO;IACT;IAEA,+CAA+C;IAC/C,IAAIC,gBAAgB;QAClB,IAAK,MAAMI,OAAOJ,eAAgB;YAChC,IAAIF,kCAAkCE,cAAc,CAACI,IAAI,GAAG;gBAC1D,OAAO;YACT;QACF;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 2296, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2301, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(\n    new URL(href, origin),\n    [currentTree[0], currentTree[1], currentTree[2], 'refetch'],\n    includeNextUrl ? state.nextUrl : null,\n    state.buildId\n  )\n\n  return cache.lazyData.then(\n    async ([flightData, canonicalUrlOverride]) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const flightDataPath of flightData) {\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const [treePatch] = flightDataPath\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // The one before last item is the router state tree patch\n        const [cacheNodeSeedData, head] = flightDataPath.slice(-2)\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[2]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n          mutable.prefetchCache = new Map()\n        }\n\n        await refreshInactiveParallelSegments({\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n"],"names":["refreshReducer","state","action","origin","mutable","href","canonicalUrl","currentTree","tree","preserveCustomHistoryState","cache","createEmptyCacheNode","includeNextUrl","hasInterceptionRouteInCurrentTree","lazyData","fetchServerResponse","URL","nextUrl","buildId","then","flightData","canonicalUrlOverride","handleExternalUrl","pushRef","pendingPush","flightDataPath","length","console","log","treePatch","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","canonicalUrlOverrideHref","createHrefFromUrl","undefined","cacheNodeSeedData","head","slice","rsc","prefetchRsc","fillLazyItemsTillLeafWithHead","prefetchCache","Map","refreshInactiveParallelSegments","updatedTree","updatedCache","patchedTree","handleMutable"],"mappings":"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"}},
    {"offset": {"line": 2399, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2404, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/fast-refresh-reducer.ts"],"sourcesContent":["import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  FastRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction fastRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: FastRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(\n    new URL(href, origin),\n    [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    includeNextUrl ? state.nextUrl : null,\n    state.buildId\n  )\n\n  return cache.lazyData.then(\n    ([flightData, canonicalUrlOverride]) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const flightDataPath of flightData) {\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const [treePatch] = flightDataPath\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(currentCache, cache, flightDataPath)\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction fastRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: FastRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const fastRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? fastRefreshReducerNoop\n    : fastRefreshReducerImpl\n"],"names":["fastRefreshReducerImpl","state","action","origin","mutable","href","canonicalUrl","preserveCustomHistoryState","cache","createEmptyCacheNode","includeNextUrl","hasInterceptionRouteInCurrentTree","tree","lazyData","fetchServerResponse","URL","nextUrl","buildId","then","flightData","canonicalUrlOverride","handleExternalUrl","pushRef","pendingPush","currentTree","currentCache","flightDataPath","length","console","log","treePatch","newTree","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","canonicalUrlOverrideHref","createHrefFromUrl","undefined","applied","applyFlightData","patchedTree","handleMutable","fastRefreshReducerNoop","_action","fastRefreshReducer","process"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAkBA,wFAAwF;AACxF,SAASA,uBACPC,KAA2B,EAC3BC,MAAyB;IAEzB,MAAM,EAAEC,MAAM,EAAE,GAAGD;IACnB,MAAME,UAAmB,CAAC;IAC1B,MAAMC,OAAOJ,MAAMK,YAAY;IAE/BF,QAAQG,0BAA0B,GAAG;IAErC,MAAMC,QAAmBC,CAAAA,GAAAA,qYAAAA,CAAAA,uBAAAA;IACzB,sFAAsF;IACtF,sHAAsH;IACtH,MAAMC,iBAAiBC,CAAAA,GAAAA,8cAAAA,CAAAA,oCAAAA,EAAkCV,MAAMW,IAAI;IAEnE,uDAAuD;IACvD,wCAAwC;IACxCJ,MAAMK,QAAQ,GAAGC,CAAAA,GAAAA,waAAAA,CAAAA,sBAAAA,EACf,IAAIC,IAAIV,MAAMF,SACd;QAACF,MAAMW,IAAI,CAAC,EAAE;QAAEX,MAAMW,IAAI,CAAC,EAAE;QAAEX,MAAMW,IAAI,CAAC,EAAE;QAAE;KAAU,EACxDF,iBAAiBT,MAAMe,OAAO,GAAG,MACjCf,MAAMgB,OAAO;IAGf,OAAOT,MAAMK,QAAQ,CAACK,IAAI,CACxB,CAAA;YAAC,CAACC,YAAYC,qBAAqB,GAAA;QACjC,4DAA4D;QAC5D,IAAI,OAAOD,eAAe,UAAU;YAClC,OAAOE,CAAAA,GAAAA,4aAAAA,CAAAA,oBAAAA,EACLpB,OACAG,SACAe,YACAlB,MAAMqB,OAAO,CAACC,WAAW;QAE7B;QAEA,+DAA+D;QAC/Df,MAAMK,QAAQ,GAAG;QAEjB,IAAIW,cAAcvB,MAAMW,IAAI;QAC5B,IAAIa,eAAexB,MAAMO,KAAK;QAE9B,KAAK,MAAMkB,kBAAkBP,WAAY;YACvC,oFAAoF;YACpF,IAAIO,eAAeC,MAAM,KAAK,GAAG;gBAC/B,oCAAoC;gBACpCC,QAAQC,GAAG,CAAC;gBACZ,OAAO5B;YACT;YAEA,mGAAmG;YACnG,MAAM,CAAC6B,UAAU,GAAGJ;YACpB,MAAMK,UAAUC,CAAAA,GAAAA,4bAAAA,CAAAA,8BAAAA,EAEd;gBAAC;aAAG,EACJR,aACAM,WACA7B,MAAMK,YAAY;YAGpB,IAAIyB,YAAY,MAAM;gBACpB,OAAOE,CAAAA,GAAAA,0aAAAA,CAAAA,wBAAAA,EAAsBhC,OAAOC,QAAQ4B;YAC9C;YAEA,IAAII,CAAAA,GAAAA,4bAAAA,CAAAA,8BAAAA,EAA4BV,aAAaO,UAAU;gBACrD,OAAOV,CAAAA,GAAAA,4aAAAA,CAAAA,oBAAAA,EACLpB,OACAG,SACAC,MACAJ,MAAMqB,OAAO,CAACC,WAAW;YAE7B;YAEA,MAAMY,2BAA2Bf,uBAC7BgB,CAAAA,GAAAA,0aAAAA,CAAAA,oBAAAA,EAAkBhB,wBAClBiB;YAEJ,IAAIjB,sBAAsB;gBACxBhB,QAAQE,YAAY,GAAG6B;YACzB;YACA,MAAMG,UAAUC,CAAAA,GAAAA,oaAAAA,CAAAA,kBAAAA,EAAgBd,cAAcjB,OAAOkB;YAErD,IAAIY,SAAS;gBACXlC,QAAQI,KAAK,GAAGA;gBAChBiB,eAAejB;YACjB;YAEAJ,QAAQoC,WAAW,GAAGT;YACtB3B,QAAQE,YAAY,GAAGD;YAEvBmB,cAAcO;QAChB;QACA,OAAOU,CAAAA,GAAAA,8ZAAAA,CAAAA,gBAAAA,EAAcxC,OAAOG;IAC9B,GACA,IAAMH;AAEV;AAEA,SAASyC,uBACPzC,KAA2B,EAC3B0C,OAA0B;IAE1B,OAAO1C;AACT;AAEO,MAAM2C,qBACXC,6EAEI7C"}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2499, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/server-action-reducer.ts"],"sourcesContent":["import type {\n  ActionFlightResponse,\n  ActionResult,\n  FlightData,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport {\n  ACTION,\n  NEXT_ROUTER_STATE_TREE,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { createFromFetch } from 'react-server-dom-webpack/client'\n// // eslint-disable-next-line import/no-extraneous-dependencies\n// import { encodeReply } from 'react-server-dom-webpack/client'\nconst { createFromFetch, encodeReply } = (\n  !!process.env.NEXT_RUNTIME\n    ? // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client.edge')\n    : // eslint-disable-next-line import/no-extraneous-dependencies\n      require('react-server-dom-webpack/client')\n) as typeof import('react-server-dom-webpack/client')\n\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  ServerActionAction,\n  ServerActionMutable,\n} from '../router-reducer-types'\nimport { addBasePath } from '../../../add-base-path'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  actionResult?: ActionResult\n  actionFlightData?: FlightData | undefined | null\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const body = await encodeReply(actionArgs)\n\n  const res = await fetch('', {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION]: actionId,\n      [NEXT_ROUTER_STATE_TREE]: encodeURIComponent(JSON.stringify(state.tree)),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  const location = res.headers.get('x-action-redirect')\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = {\n      paths: [],\n      tag: false,\n      cookie: false,\n    }\n  }\n\n  const redirectLocation = location\n    ? new URL(\n        addBasePath(location),\n        // Ensure relative redirects in Server Actions work, e.g. redirect('./somewhere-else')\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  let isFlightResponse =\n    res.headers.get('content-type') === RSC_CONTENT_TYPE_HEADER\n\n  if (isFlightResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      {\n        callServer,\n      }\n    )\n\n    if (location) {\n      // if it was a redirection, then result is just a regular RSC payload\n      const [, actionFlightData] = (response as any) ?? []\n      return {\n        actionFlightData: actionFlightData,\n        redirectLocation,\n        revalidatedParts,\n      }\n    }\n\n    // otherwise it's a tuple of [actionResult, actionFlightData]\n    const [actionResult, [, actionFlightData]] = (response as any) ?? []\n    return {\n      actionResult,\n      actionFlightData,\n      redirectLocation,\n      revalidatedParts,\n    }\n  }\n  return {\n    redirectLocation,\n    revalidatedParts,\n  }\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  mutable.inFlightServerAction = fetchServerAction(state, nextUrl, action)\n\n  return mutable.inFlightServerAction.then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n    }) => {\n      // Make sure the redirection is a push instead of a replace.\n      // Issue: https://github.com/vercel/next.js/issues/53911\n      if (redirectLocation) {\n        state.pushRef.pendingPush = true\n        mutable.pendingPush = true\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.data as it has been resolved at this point.\n      mutable.inFlightServerAction = null\n\n      for (const flightDataPath of flightData) {\n        // FlightDataPath with more than two items means unexpected Flight data was returned\n        if (flightDataPath.length !== 3) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const [treePatch] = flightDataPath\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectLocation\n            ? createHrefFromUrl(redirectLocation)\n            : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The one before last item is the router state tree patch\n        const [cacheNodeSeedData, head] = flightDataPath.slice(-2)\n        const rsc = cacheNodeSeedData !== null ? cacheNodeSeedData[2] : null\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (rsc !== null) {\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          fillLazyItemsTillLeafWithHead(\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head\n          )\n\n          await refreshInactiveParallelSegments({\n            state,\n            updatedTree: newTree,\n            updatedCache: cache,\n            includeNextUrl: Boolean(nextUrl),\n          })\n\n          mutable.cache = cache\n          mutable.prefetchCache = new Map()\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n\n      if (redirectLocation) {\n        const newHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = newHref\n      }\n\n      resolve(actionResult)\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n"],"names":["createFromFetch","encodeReply","fetchServerAction","state","nextUrl","actionId","actionArgs","body","res","fetch","method","headers","Accept","RSC_CONTENT_TYPE_HEADER","ACTION","NEXT_ROUTER_STATE_TREE","encodeURIComponent","JSON","stringify","tree","process","NEXT_URL","location","get","revalidatedParts","revalidatedHeader","parse","paths","tag","cookie","e","redirectLocation","URL","addBasePath","canonicalUrl","window","href","undefined","isFlightResponse","response","Promise","resolve","callServer","actionFlightData","actionResult","serverActionReducer","action","reject","mutable","currentTree","preserveCustomHistoryState","hasInterceptionRouteInCurrentTree","inFlightServerAction","then","flightData","pushRef","pendingPush","handleExternalUrl","flightDataPath","length","console","log","treePatch","newTree","applyRouterStatePatchToTree","createHrefFromUrl","handleSegmentMismatch","isNavigatingToNewRootLayout","cacheNodeSeedData","head","slice","rsc","cache","createEmptyCacheNode","prefetchRsc","fillLazyItemsTillLeafWithHead","refreshInactiveParallelSegments","updatedTree","updatedCache","includeNextUrl","Boolean","prefetchCache","Map","patchedTree","newHref","handleMutable"],"mappings":"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"}},
    {"offset": {"line": 2681, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2686, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/router-reducer.ts"],"sourcesContent":["import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_FAST_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { fastRefreshReducer } from './reducers/fast-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_FAST_REFRESH: {\n      return fastRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n"],"names":["clientReducer","state","action","type","ACTION_NAVIGATE","navigateReducer","ACTION_SERVER_PATCH","serverPatchReducer","ACTION_RESTORE","restoreReducer","ACTION_REFRESH","refreshReducer","ACTION_FAST_REFRESH","fastRefreshReducer","ACTION_PREFETCH","prefetchReducer","ACTION_SERVER_ACTION","serverActionReducer","Error","serverReducer","_action","reducer","window"],"mappings":";;;;;;;;;;;;;;;;;;;;AAsBA;;CAEC,GACD,SAASA,cACPC,KAA2B,EAC3BC,MAAsB;IAEtB,OAAQA,OAAOC,IAAI;QACjB,KAAKC,uaAAAA,CAAAA,kBAAAA;YAAiB;gBACpB,OAAOC,CAAAA,GAAAA,4aAAAA,CAAAA,kBAAAA,EAAgBJ,OAAOC;YAChC;QACA,KAAKI,uaAAAA,CAAAA,sBAAAA;YAAqB;gBACxB,OAAOC,CAAAA,GAAAA,mbAAAA,CAAAA,qBAAAA,EAAmBN,OAAOC;YACnC;QACA,KAAKM,uaAAAA,CAAAA,iBAAAA;YAAgB;gBACnB,OAAOC,CAAAA,GAAAA,2aAAAA,CAAAA,iBAAAA,EAAeR,OAAOC;YAC/B;QACA,KAAKQ,uaAAAA,CAAAA,iBAAAA;YAAgB;gBACnB,OAAOC,CAAAA,GAAAA,2aAAAA,CAAAA,iBAAAA,EAAeV,OAAOC;YAC/B;QACA,KAAKU,uaAAAA,CAAAA,sBAAAA;YAAqB;gBACxB,OAAOC,CAAAA,GAAAA,mbAAAA,CAAAA,qBAAAA,EAAmBZ,OAAOC;YACnC;QACA,KAAKY,uaAAAA,CAAAA,kBAAAA;YAAiB;gBACpB,OAAOC,CAAAA,GAAAA,4aAAAA,CAAAA,kBAAAA,EAAgBd,OAAOC;YAChC;QACA,KAAKc,uaAAAA,CAAAA,uBAAAA;YAAsB;gBACzB,OAAOC,CAAAA,GAAAA,obAAAA,CAAAA,sBAAAA,EAAoBhB,OAAOC;YACpC;QACA,+DAA+D;QAC/D;YACE,MAAM,IAAIgB,MAAM;IACpB;AACF;AAEA,SAASC,cACPlB,KAA2B,EAC3BmB,OAAuB;IAEvB,OAAOnB;AACT;AAGO,MAAMoB,UACX,OAAOC,WAAW,cAAcH,gBAAgBnB"}},
    {"offset": {"line": 2747, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2752, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/get-segment-value.ts"],"sourcesContent":["import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n"],"names":["getSegmentValue","segment","Array","isArray"],"mappings":";;;AAEO,SAASA,gBAAgBC,OAAgB;IAC9C,OAAOC,MAAMC,OAAO,CAACF,WAAWA,OAAO,CAAC,EAAE,GAAGA;AAC/C"}},
    {"offset": {"line": 2758, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2763, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/create-initial-router-state.ts"],"sourcesContent":["import type { ReactNode } from 'react'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n  FlightData,\n} from '../../../server/app-render/types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\nimport { createPrefetchCacheEntryForInitialLoad } from './prefetch-cache-utils'\nimport { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\nexport interface InitialRouterStateParameters {\n  buildId: string\n  initialTree: FlightRouterState\n  initialCanonicalUrl: string\n  initialSeedData: CacheNodeSeedData\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  location: Location | null\n  initialHead: ReactNode\n  couldBeIntercepted?: boolean\n}\n\nexport function createInitialRouterState({\n  buildId,\n  initialTree,\n  initialSeedData,\n  initialCanonicalUrl,\n  initialParallelRoutes,\n  location,\n  initialHead,\n  couldBeIntercepted,\n}: InitialRouterStateParameters) {\n  const isServer = !location\n  const rsc = initialSeedData[2]\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc: rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: isServer ? new Map() : initialParallelRoutes,\n    lazyDataResolved: false,\n    loading: initialSeedData[3],\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead\n    )\n  }\n\n  const initialState = {\n    buildId,\n    tree: initialTree,\n    cache,\n    prefetchCache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n  }\n\n  if (location) {\n    // Seed the prefetch cache with this page's data.\n    // This is to prevent needlessly re-prefetching a page that is already reusable,\n    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n    const url = new URL(location.pathname, location.origin)\n\n    const initialFlightData: FlightData = [['', initialTree, null, null]]\n    createPrefetchCacheEntryForInitialLoad({\n      url,\n      kind: PrefetchKind.AUTO,\n      data: [initialFlightData, undefined, false, couldBeIntercepted],\n      tree: initialState.tree,\n      prefetchCache: initialState.prefetchCache,\n      nextUrl: initialState.nextUrl,\n    })\n  }\n\n  return initialState\n}\n"],"names":["createInitialRouterState","buildId","initialTree","initialSeedData","initialCanonicalUrl","initialParallelRoutes","location","initialHead","couldBeIntercepted","isServer","rsc","cache","lazyData","prefetchRsc","head","prefetchHead","parallelRoutes","Map","lazyDataResolved","loading","canonicalUrl","createHrefFromUrl","addRefreshMarkerToActiveParallelSegments","prefetchCache","size","fillLazyItemsTillLeafWithHead","undefined","extractPathFromFlightRouterState","initialState","tree","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","onlyHashChange","hashFragment","segmentPaths","nextUrl","pathname","url","URL","origin","initialFlightData","createPrefetchCacheEntryForInitialLoad","kind","PrefetchKind","AUTO","data"],"mappings":";;;;;;;;;;;;;;;;AA0BO,SAASA,yBAAyB,KASV;IATU,IAAA,EACvCC,OAAO,EACPC,WAAW,EACXC,eAAe,EACfC,mBAAmB,EACnBC,qBAAqB,EACrBC,QAAQ,EACRC,WAAW,EACXC,kBAAkB,EACW,GATU;IAUvC,MAAMC,WAAW,CAACH;IAClB,MAAMI,MAAMP,eAAe,CAAC,EAAE;IAE9B,MAAMQ,QAAmB;QACvBC,UAAU;QACVF,KAAKA;QACLG,aAAa;QACbC,MAAM;QACNC,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBP,WAAW,IAAIQ,QAAQZ;QACvCa,kBAAkB;QAClBC,SAAShB,eAAe,CAAC,EAAE;IAC7B;IAEA,MAAMiB,eAEJ,kJAAkJ;IAClJd,WAEIe,CAAAA,GAAAA,0aAAAA,CAAAA,oBAAAA,EAAkBf,YAClBF;IAENkB,CAAAA,GAAAA,wbAAAA,CAAAA,2CAAAA,EAAyCpB,aAAakB;IAEtD,MAAMG,gBAAgB,IAAIN;IAE1B,yEAAyE;IACzE,IAAIZ,0BAA0B,QAAQA,sBAAsBmB,IAAI,KAAK,GAAG;QACtEC,CAAAA,GAAAA,kcAAAA,CAAAA,gCAAAA,EACEd,OACAe,WACAxB,aACAC,iBACAI;IAEJ;QAuBKoB;IArBL,MAAMC,eAAe;QACnB3B;QACA4B,MAAM3B;QACNS;QACAY;QACAO,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAlB;QACAmB,SAEE,CAACZ,OAAAA,CAAAA,GAAAA,uaAAAA,CAAAA,mCAAAA,EAAiCzB,gBAAAA,CAAgBI,YAAAA,OAAAA,KAAAA,IAAAA,SAAUkC,QAAQ,CAAA,KAAA,OAAnEb,OACD;IACJ;IAEA,IAAIrB,UAAU;QACZ,iDAAiD;QACjD,gFAAgF;QAChF,+FAA+F;QAC/F,MAAMmC,MAAM,IAAIC,IAAIpC,SAASkC,QAAQ,EAAElC,SAASqC,MAAM;QAEtD,MAAMC,oBAAgC;YAAC;gBAAC;gBAAI1C;gBAAa;gBAAM;aAAK;SAAC;QACrE2C,CAAAA,GAAAA,uaAAAA,CAAAA,yCAAAA,EAAuC;YACrCJ;YACAK,MAAMC,uaAAAA,CAAAA,eAAAA,CAAaC,IAAI;YACvBC,MAAM;gBAACL;gBAAmBlB;gBAAW;gBAAOlB;aAAmB;YAC/DqB,MAAMD,aAAaC,IAAI;YACvBN,eAAeK,aAAaL,aAAa;YACzCgB,SAASX,aAAaW,OAAO;QAC/B;IACF;IAEA,OAAOX;AACT"}},
    {"offset": {"line": 2853, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2858, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/node_modules/.pnpm/next@14.3.0-canary.64_@babel+core@7.24.5_@opentelemetry+api@1.8.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/src/client/components/router-reducer/reducers/find-head-in-cache.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string\n): [CacheNode, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix]\n  }\n  for (const key in parallelRoutes) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey\n    )\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","isLastItem","Object","keys","length","key","segment","childParallelRoutes","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheNode","item"],"mappings":";;;;;;AAIO,SAASA,gBACdC,KAAgB,EAChBC,cAAoC;IAEpC,OAAOC,oBAAoBF,OAAOC,gBAAgB;AACpD;AAEA,SAASC,oBACPF,KAAgB,EAChBC,cAAoC,EACpCE,SAAiB;IAEjB,MAAMC,aAAaC,OAAOC,IAAI,CAACL,gBAAgBM,MAAM,KAAK;IAC1D,IAAIH,YAAY;QACd,0EAA0E;QAC1E,OAAO;YAACJ;YAAOG;SAAU;IAC3B;IACA,IAAK,MAAMK,OAAOP,eAAgB;QAChC,MAAM,CAACQ,SAASC,oBAAoB,GAAGT,cAAc,CAACO,IAAI;QAC1D,MAAMG,kBAAkBX,MAAMC,cAAc,CAACW,GAAG,CAACJ;QACjD,IAAI,CAACG,iBAAiB;YACpB;QACF;QAEA,MAAME,WAAWC,CAAAA,GAAAA,6aAAAA,CAAAA,uBAAAA,EAAqBL;QAEtC,MAAMM,YAAYJ,gBAAgBC,GAAG,CAACC;QACtC,IAAI,CAACE,WAAW;YACd;QACF;QAEA,MAAMC,OAAOd,oBACXa,WACAL,qBACAP,YAAY,MAAMU;QAEpB,IAAIG,MAAM;YACR,OAAOA;QACT;IACF;IAEA,OAAO;AACT"}},
    {"offset": {"line": 2894, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}